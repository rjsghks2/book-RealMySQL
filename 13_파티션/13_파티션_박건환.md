# 파티션
## 13.1 개요

Q. 파티션이 필요한 대표적인 예는?
> 데이터의 특성상 주기적인 삭제가 필요한 경우, 테이블이 너무 커서 인덱스의 크기가 물리적은 메모리의 크기보다 큰 경우

Q. 워킹 셋(Working Set) 이란?
> 테이블 데이터에서 활발하게 사용되는 부분

### 13.1.2 MySQL 파티션의 내부 처리

Q. SQL이 수행되기 위해 파티션 테이블을 검색 할 때 성능에 크게 영향을 미치는조건은?
1) WHERE 절의 조건으로 ()을 선택할 수 있는가?
2) WHERE 절의 조건이 ()를 효율적으로 사용할 수 있는가?
> 검색해야할 파티션, 인덱스

Q. 여러 파티션에 대해 인덱스 스캔을 수행하면, 별도의 정렬 작업 없이 정렬된 결과를 바로 반환한다. (O/X)
> X. 별도의 정렬 작업은 없으나, 결과를 바로 반환하는것이 아니라 내부적으로 큐 처리 작업이 수행된다.

Q. 파티션 프루닝이란?
> 최적화 단계에서 필요한 파티션만 골라내고 불 필요한것들은 실행계획에서 배제하는 것

## 13.2 주의사항
* 종류에 관계없이 테이블에 유니크 인덱스(프라이머리 키 포함)가 있으면 파티션키는 모든 유니크인덱스의 일부 또는 모든 컬럼을 추가해야 한다.

### 13.2.2 파티션과 Open_file_limit 시스템 변수 설정
Q. 파티션 테이블이 많을 때 Open_file_limit을 적절하게 설정해줘야 하는 이유는?
> MySQL 에서는 일반적으로 테이블을 파일단위로 관리하는데, 파티션 테이블의 경우 파티션 프루닝이 수행되더라도 일단 동시에 모든 데이터파일을 오픈해야 하기 때문에 성능 관리를 위해 적절하게 설정해줘야 한다.

## 13.3 MySQL 파티션의 종류
Q. 파티션의 종류 4가지와 용도를 간단히 설명하시오.
> 레인지 파티션: 가장 일반적인 방법으로, 파티션키의 연속된 범위로 파티션을 정의하는 방법 

> 리스트 파티션 : 파티션 키 값을 하나하나 리스트로 나열해줘야 하는 파티션 정의 방법 , 리스트, 해시, 키 파티션

> 해시 파티션 : MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법

> 키 파티션 : 해시 파티션과 유사하나, 해시 파티션은 해시 값 계산 방법을 사용자가 명시하는 반면에, 키 파티션은 해시 값의 계산도 MySQL 서버가 수행하게 하는 방법이다. (파티션 키 값을 설정해줌)

# 스토어드 프로그램

## 14.2 스토어드 프로그램의 문법
### 14.2.2 스토어드 프로시저
Q. 스토어드 프로시저란 서로 데이터를 주고받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 () 으로 실행 하기 위해 사용하는 것이다.
> 독립적

Q. 스토어드 프로시저와 스토어드 함수의 차이는?
> 리턴값 유무, 스토어드 함수는
> SQL 문장의 일부로 사용할 수 있음.

### 14.2.4 트리거
Q. 트리거란 레코드가 ()되거나 ()될 때 미리 정의해둔 작업을 자동으로 실행해주는 스토어드 프로그램이다.
> 저장, 변경

Q. 바이너리 로그 포맷(ROW, STATEMENT) 에 따른 트리거의 동작방식 차이는 ?
> 바이너리 로그 포맷이 ROW일 경우에는 복제서버에 트리거가 기동되지 않지만, STATEMENT의 경우 복제서버에서 트리거가 기동된다.

### 14.2.5 이벤트
Q. 주어신 특정한 시간에 스토어드 프로그램을 실행 할 수 있는 스케줄러 기능을 () 라고 한다.
> 이벤트

Q. ENABLE 상태의 이벤트가 생성되어 있을 때 레플리카 서버가 소스서버로 승격 될 경우 수동으로 이벤트의 상태를 ENABLE 상태로 변경해야 한다.(O/X)
> O

### 14.2.6 스토어드 프로그램 본문(Body) 작성
Q. SQLSTATE와 에러 번호(Error No) 의 차이는? 
> 에러 번호 : 4가지 숫자로 구성되고, MySQL에서만 유효한 에러 식별코드

> SQLSTATE : 다섯글자의 알파벳과 숫자로 구성되며, 에러뿐만 아니라 여러 상태를 의미한다. 그리고 표준값이므로 특정 벤더에 의존적이지 않다.

Q. 핸들러란 ? 
> 스토어드 프로그램에서 에러나 예외를 처리하는 기능

Q. 핸들러 생성 구문은 다음과 같다.
DECLARE (1. handler_type) HANDLER
FOR (2. condition_value) [, condition_value] ...
(3. handler_statements)
여기서 1, 2, 3번을 간단히 설명하시오

> 1. handler_type : 핸들러의 유형을 지정하는 부분
> 2. condition_value : 핸들러가 작동할 조건을 지정하는 부분
> 3. handler_statements : 핸들러가 실행될 때 처리될 SQL 문장들을 지정하는 부분

Q. Handler_type 에서 EXIT과 CONTINUE의 차이는?
> EXIT : 현재 핸들러가 최상위 BEGIN…END 블록에 정의됐다면 현재 스토어드 프로그램을 벗어나서 종료

> CONTINUE : handler_statements를 실행하고 스토어드 프로그램의 마지막 실행 지점으로 다시 돌아가 나머지 코드를 처리

Q. SIGNAL 이란 ?
> 스토어드 프로그램에서 예외를 강제로 발생시키는 데 사용되는 명령문

Q. 커서는 센서티브 커서와 인센서티브 커서로 나눌 수 있다. 두 가지의 차이는?
> 센서티브 커서 : 일치하는 레코드에 대한 정보를 실제 레코드의 포인터만으로 유지하는 형태
> 인센서티브 커서 : 일치하는 레코드를 별도의 임시 테이블로 복사해서 가지고 있는 형태

Q. 스토어드 프로그램을 실행할 때 권한과 관련되어 SQL SECURITY 옵션의 DEFINER와 INVOKER가 있다. 두 가지의 차이는?
> DEFINER : DEFINER로 지정된 사용자의 권한으로 실행
> INVOKER : 호출한 사용자의 권한으로 실행됩니다.

