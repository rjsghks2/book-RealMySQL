# 복제
## 16.2 복제 아키텍처
Q. MySQL 서버에서 발생하는 모든 변경사항은 ()에 저장되고, 변경 사항들을 () 라고 한다.
> Binary Log, event

Q. 레플리카 서버에서 소스서버의 로그를 읽어 들여 따로 로컬 디스크에 저장해둔 파일을 () 라고 한다.

## 16.3 복제 타입
Q. MySQL 복제의 두 가지 방법은?
> 바이너리 로그 파일 위치 기반 복제, 글로벌 트랜잭션 ID 기반 복제

### 16.3.1 바이너리 로그 파일 위치 기반 복제
Q. 바이너리 로그 파일 위치 기반 복제에서 복제에 참여한 MySQL 서버들은 모두 같은 server_id 값을 가지고 있어야 한다.(O/X)
> X

Q. 소스 서버에서 바이너리 로그가 정상적으로 기록되고 있는지 확인하는 명령어는 ?
> SHOW MASTER STATUS;

Q. mysqldump를 사용 할 때 소스 서버의 바이너리 로그 파일명과 위치 정보를 기록 할 수 있는 옵션은?
> --master-data 옵션

### 16.3.2 글로벌 트랜잭션 아이디(GTID) 기반 복제
Q. 바이너리 로그 파일 위치 기반 복제에 비해 GTID 기반 복제가 가진 장점은?
> 데이터 정합성, 온라인으로 GTID 설정 가능

Q. GTID 기반 복제가 가진 제약사항은?
> 일관성을 해칠 수 있는 일부 유형의 쿼리는 사용 불가

## 16.4 복제 데이터 포맷
Q. 복제 데이터 포맷 3가지는 ?
> ROW, STATEMENT, MIXED

### 16.4.1 Statement 기반 바이너리 로그 포뱃
Q. Statement 기반 바이너리 로그 포맷을 사용할 때는 트랜잭션 격리 수준이 항상 () 이상이어야 한다.
> REPEATABLE-READ

### 16.4.2 ROW 기반 바이너리 로그 포맷
Q. 데이터 변경이 발생했을 때 ROW 기반 바이너리 로그 포맷을 사용하면 바이너리 로그에 어떤 값이 기록되는가?
> 변경된 값

Q. ROW 포맷은 모든 트랜잭션 격리 수준에서 사용 가능하다(O/X)
> O

### 16.4.4 ROW 포맷의 용량 최적화
Q. 대체적으로 STATEMENT 포맷인 경우보다 ROW 포맷일때 바이너리 로그 파일의 크기가 크다. 그 이유는?
>  Row포맷의 경우 변경된 데이터들이 전부 저장되기 때문에

Q. 바이너리 로그를 압축할 때 사용하는 binlog_transaction_compression,  binlog_transaction_compression_level_zstd 변수는 글로벌 레벨에서만 조정 가능하다. (O/X)
> X

## 16.5 복제 동기화 방식
Q. 복제 동기화 방식에는 비동기 복제, 반동기 복제가 있다. 차이점은 ?
> 비동기 복제 : 소스 서버가 자신과 복제 연결된 레플리카서버에서 변경 이벤트가 정상적으로전달되어 적용됐는지를 확인하지 않는 방식
> 반동기 복제 : 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답(ACK)을 보내면 트랜잭션을 완전히 커밋시키고 클라이언트에 결과를 반환한다.

### 16.5.2 반동기 복제
Q. 반동기 복제에서  AFTER COMMIT 과 AFTER SYNC의 차이는 ?
> 응답을 기다리는 지점의 차이.
> AFTER SYNC : 스토리지 엔진에 커밋하기 전 단계에서 레플리카 서버의 응답을 기다리는 것.
> AFTER COMMIT : 스토리지 엔진에 커밋한 후 레플리카 서버의 응답을 기다리는 것.

 
