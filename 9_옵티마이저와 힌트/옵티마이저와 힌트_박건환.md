# 9 옵티마이저와 힌트

## 9.1 개요

### 9.1.1 쿼리 실행 절차
Q. 쿼리 실행 3단계는 ?
> SQL 파싱, 실행계획 수립, 로우 소스 생성


### 9.1.2 옵티마이저의 종류
Q. 옵티마이저의 종류 두 가지는 ? 
> 비용기반 최적화 (CBO) , 규칙 기반 최적화 (RBO)

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
Q. 풀 테이블 스캔과 풀 인덱스 스캔을 설명하시오.
> 풀 테이블 스캔 : 인덱스를 사용하지 않고 테이블을 처음부터 끝까지 읽어서 처리한다.
> 풀 인덱스 스캔 : 인덱스를 처음부터 끝까지 읽어서 처리한다

Q. 풀 테이블 스캔이 발생하는 이유 3가지는?
> 테이블 레코드 건수가 너무 적어서 인덱스를 통해 읽는 것보다 테이블을 직접 읽는 것이 빠를 때
> 인덱스를 사용할 적절한 Where, On 절 조건이 없을 때
> 일치하는 데이터 건수가 너무 많을 때

Q. 리드 어헤드 기능은 테이블 풀 스캔 시에만 적용되는가 ? (O/X)
> X. 인덱스 풀 스캔 시에도 적용된다. 

### 9.2.2 병렬 처리 
Q. MySQL에서 병렬 처리란?
> 하나의 쿼리를 여러 스레드가 처리하는 방식

### 9.2.3 Order by 처리
Q. 정렬 처리 방법의 두 가지를 설명하시오
> 인덱스를 이용한 정렬, Filesort를 이용한 정렬

Q. 소트 버퍼란 ?
> MySQL에서 정렬을 수행하기 위해 만들어둔 메모리 공간이다. 

Q. 소트 버퍼는 공유 메모리인가? 아니면 세션 메모리인가?
> 세션 메모리

Q. 싱글 패스 정렬방식과 투 패스 정렬방식의 차이점은?
> 투패스 정렬방식은 테이블을 두 번 읽어야 하므로 상당히 비용이 많이 든다. 
> 싱글 패스 정렬방식은 테이블을 한번만 읽어도 되지만, 소트 버퍼의 공간을 많이 사용한다.
 
Q. Order by 방식 세가지
> 인덱스를 이용한 정렬, 조인의 드라이빙 테이블만 정렬, 조인 결과를 임시 테이블에 저장 후 정렬

Q. 정렬 처리 방식에는 스트리밍 방식과 버퍼링 방식이 있다. 다음 세가지 CASE는 어떤 방식을 사용하는가 ?
 1. 인덱스를 이용한 정렬
 2. 조인의 드라이빙 테이블만 정렬
 3. 조인 결과를 임시 테이블에 저장 후 정렬)
> 인덱스를 이용한 정렬 방식만 스트리밍 형태의 처리이고 나머지는 모두 버퍼링 방식이다. 

### 9.2.4 GROUP BY 처리
Q. GROUP BY 작업 시 인덱스 이용 할 때와 인덱스를 이용하지 않을 때의 차이점은 ?
> 인덱스를 이용하지 않는다면, 임시 테이블을 생성한다.

### 9.2.5 DISTINCT 처리 
Q. 아래 두 구문의 차이는 ?
select distinct emp_no from salaries;
select count(distinct emp_no) from salaries;
> 첫번째 구문은 group by 처리와 동일하게 수행되고, 두번쨰 구문은 임시 테이블을 생성하여 수행된다.

### 9.2.6 내부 임시 테이블 활용
Q. 메모리는 (       )이라는 스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 (     ) 스토리지 엔진을 사용한다
> TempTable, InnoDB

Q. 임시 테이블이 디스크에생성되는 경우는 ?
> Union이나 union all에서 select되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
> group by나 distinct 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
> 메모리 임시 테이블의 크기가 temp_table_max_ram 시스템 변수 값보다 큰 경우

Q. 내부적인 임시 테이블은 쿼리 수행중 필요시 메모리에 생성되는데, 쿼리가 완료되면 생성된 임시 테이블은 사라진다 (O/X) 
> O

## 9.3 고급 최적화
Q. 옵티마이저는 실행 계획을 수립할 때 () 정보와 () 정보를 결합 하여 최적의 실행 계획을 수립한다.
> 통계 정보, 옵티마이저 옵션

### 9.3.1 옵티마이저 스위치 옵션
Q. 네스티드 루프 조인과 블록 네스티드 루프 조인의 차이는?
> 조인 버퍼 사용 여부, 드라이빙 테이블, 드리븐 테이블의 처리 순서

Q. 조인 버퍼를 사용할 때 결과 집합이 흐트러질 수 있는 이유는?
> 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식이기 때문에

Q. 인덱스 컨디션 푸시다운(index_condition_pushdown) 이란?
> 인덱스 액세스 조건으로 사용하지 못하는 인덱스 컬럼이 쿼리 조건절에 포함되어있다면, 모두 같이 모아서 스토리지 엔진으로 전달하는 기능

Q. 인덱스 확장 (use_index_extensions) 이란?
> InnoDB 테이블에서 세컨더리 인덱스에 자동으로 추가 된 프라이머리 키를 활용할 수 있는 기능

Q. 인덱스 머지 (index_merge) 란? 
> 하나의 테이블 에 대해 2개 이상의 인덱스를 이용하는 기능

Q. 다른 테이블과 실제 조인을 수행하지는 않고 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 방식을 ( ) 이라고 한다
> 세미 조인

Q. 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성 하는 형태의 최적화를 ( ) 이라고 한다.
> 테이블 풀 아웃

Q. IN 연산자와 EXISTS 연산자의 쿼리 수행 순서는 ?
> exists 연산자는 메인쿼리 → 서브 쿼리
> in 연산자의 처리 순서는 서브쿼리 → 메인 쿼리

Q. Duplicate WeedOut을 설명하시오
> 세미 조인 서브쿼리를 일반적은 INNER JOIN 쿼리로 바꿔 실행하고 마지막에 중복된 레코드를 제거하는 알고리즘

Q. 파생 테이블 머지를 사용할 수 없는 경우는 ?
> 1. 집계함수, 윈도우 함수가 쓰인 쿼리
> 2. DISTINCT 사용된 서브쿼리
> 3. GROUP BY , HAVING 사용된 서브쿼리 등

Q. HASH JOIN은 ( ) 단계와 ( ) 단계로 나뉘어 처리된다
> 빌드 단계, 프루브 단계

Q. ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 () 옵티마이저 옵션이 추가 되었다
> prefer_ordering_index 

### 9.3.2 조인 최적화 알고리즘 
