# 8 인덱스

## 8.1 디스크 읽기 방식

### 8.1.2 랜덤 I/O와 순차 I/O

Q. 일반적으로 쿼리를 튜닝하는 목적은 ?
> 랜덤 I/O 자체를 줄여주는 것이 목적입니다.

Q. 페이지를 디스크에 기록할 때 랜덤 I/O와 순차 I/O의 차이를 설명하세요.
> 랜덤 I/O는 페이지를 기록 할 때 페이지별로 시스템 콜을 요청하지만, 순차 I/O는 여러 페이지를 한번에 기록한다.

## 8.2 인덱스란?

Q. 인덱스를 사용하는 목적은 데이터의 Insert,Update,Delete,Select의 성능을 높이는 것이다.
> X. 인덱스의 목적은 데이터의 Insert,Update,Delete 의 성능을 희생하고 데이터의 읽기 속도를 높이는 것이다.

Q. 유니크 인덱스 보다 프라이머리 키로 지정된 인덱스가 항상 더 빠르다?
> X. 데이터 삽입 시에 Primary key는 Clustered Index이기 때문에 데이터가 물리적으로 정렬된 상태를 유지해야 한다. 데이터 검색시에는 프라이머리 키로 지정된 인덱스가 더 빠르지만, 데이터 저장능력은 Unique Index가 더 빠를 수 있다.

## 8.3 B-Tree 인덱스

Q. B-Tree 에서 'B'는 무슨 약자인가?
> Balanced

### 8.3.1 구조 및 특성

Q. 인덱스에서 리프 노드가 가지고 있는 값은?
> 실제 데이터 레코드를 찾아가기 위한 주솟값 (프라이머리키의 주소값)
> 프라이머리 키 인덱스의 리프 노드에는 실제 데이터를 가지고 있다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

Q. MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
   InnoDB에서는 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있는데, 이 기능을 ??? 이라고 한다.
> 체인지 버퍼

Q. B-Tree 인덱스 키 값이 대량으로 삭제되어 리프노드에 존재하는 키 값이 없으면, 리프노드는 삭제되어 삭제된 공간은 바로 디스크에 반환된다.
> X. B-Tree 인덱스의 키 값이 삭제될 경우, 해당 키 값이 저장된 리프 노드를 찾아서 삭제 마크만 하고, 나중에 재활용된다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

Q. 인덱스에서 선택도란?
> 모든 인덱스 키 값 가운데 유니크한 값의 수

Q. B-Tree 인덱스는 자식노드가 2개이다.
> X. B-Tree의 자식 노드의 개수는 가변적인 구조다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

Q. MySQL에서 인덱스를 이용하는 대표적인 스캔방법은 무엇인가?
> Index Range Scan, Index Full Scan, Loose Index Scan, Index Skip Scan

Q. Index Full Scan은 Table Full Scan 보다 항상 빠르다?
> X. 상황에 따라 다르지만, 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 든다. 데이터 레코드의 양에 따라 Table Full Scan이 더 빠를 수 있다.

Q. Loose Index Scan 방식과 Index Skip Scan 방식의 차이는?
> Loose Index Scan은 Group by 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용이 가능함
> Index skip scan은 Where 조건절의 검색을 위해 사용이 가능함

Q. Covering Index란?
> 쿼리를 충족시키는데 필요한 모든 데이터를 갖고 있는 인덱스

### 8.3.5 다중 칼럼(Multi-column) 인덱스

Q. B-Tree 인덱스에서 루트 노드/브랜치 노드/리프 노드는 항상 존재한다
> X. 브랜치노드는 없을 수도 있다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

Q. 오름차순으로 생성된 인덱스도 내림차순으로 정렬된 쿼리에 인덱스로 사용 될 수 있다. 그러면 굳이 내림차순 인덱스를 생성할 이유는 무엇인가?
> 내림차순으로 정렬된 쿼리를 실행 할 때 내림차순 인덱스를 사용하면 오름차순 인덱스보다 성능이 더 좋아진다.  
> 그 이유는 페이지 내에서의 인덱스 레코드는 단방향으로 연결된 구조이기 때문이다.

### 8.3.7 인덱스의 가용성

Q. MySQL에서 다음 쿼리는 Index Range Scan이 가능하다. 그 이유는 무엇인가 ?
mysql> .. WHERE column IS NULL .. 
> NULL값도 인덱스에 저장되기 때문에 가능함.
