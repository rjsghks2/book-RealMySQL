## 11.4.4 DISTINCT 
- 특정 칼럼의 유니크한 값을 조회하기 위해 사용한다.

Q. MySQL 기준 DISTINCT와 GROUP BY 중에 속도가 뭐가 더 빠를까?
> DISTINCT 는 중복제거 수행, GROUP BY는 중복제거에 정렬과정까지 포함하기 때문에 정렬과정이 없다면 DISTINCT가 더 빠르다. 


## 11.4.5  LIMIT n
- 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져올 때 사용한다.

Q. 비슷한 개념으로 오라클의 rownum이 있는데, 차이점은 뭘 까?
> MySQL은 WHERE 조건이 아니기 때문에 항상 쿼리의 가장 마지막에 실행되지만, 오라클의 rownum은 Where 조건절에서 사용된다.

## 11.4.6. COUNT()
- 결과 레코드의 건수를 반환하는 함수이다.
Q. COUNT() 함수에 칼럼명이나 표현식이 인자로 사용되면 그 칼럼이나 표현식의 결과에 대한 모든 건수가 반환된다.
> (X)

## 11.4.7. JOIN

### 11.4.7.1 JOIN 순서와 인덱스
Q. 옵티마이저는 항상 ()테이블이 아니라 ()테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.
>(드라이빙, 드리븐)

### 11.4.7.2 JOIN 칼럼의 데이터 타입
Q. 테이블 조인 칼럼의 데이터 타입을 동일하게 사용해야하는 이유는 ?
> 인덱스 레인지 스캔을 사용하지 못하고, 풀테이블 스캔을 수행하게 되어 조인 버퍼를 활용한 해시 조인이 사용된다.

### 11.4.7.3 OUTER JOIN의 성능과 주의사항
Q. 이너 조인으로 사용해도 되는 쿼리를 아우터 조인으로 작성하면 안되는 이유는 ?
> MySQL 옵티마이저는 아우터로 조인되는 테이블을 드라이빙 테이블로 선택하지 못하게 하기 때문에.

### 11.4.7.4 JOIN과 외래키(FOREIGN KEY)
Q. 외래키를 생성하는 주 목적은?
> 참조 무결성을 보장하기 위해

### 11.4.7.5 지연된 조인(Delayed Join)
- 지연된 조인이란, 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식
Q. 지연된 조인을 유도하는 방법은 ?
> 서브쿼리와 LIMIT 절을 사용하여, 조인하기 전에 결과집합을 줄인다.

### 11.4.7.6 래터럴 조인
Q. 래터럴 조인이란 ?
> 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것

### 11.4.7.7 실행 계획으로 인한 정렬 흐트러짐
Q. MySQL 에서는 조인쿼리 결과가 정렬된다?
> 8.0 이전에는 네스티드 루프조인의 조인만 가능했기 때문에 정렬되었지만, 8.0 이후부터는 해시조인의 도입으로 정렬이 흐트러질 수 있음.

### 11.4.8.1 WITH ROLLUP
- 그룹별로 소계를 출력하는 레코드가 포함됨.

### 11.4.8.2 레코드를 칼럼으로 변환해서 조회
- 피벗과 같은 기능. 그루핑을 먼저 수행한 후, 레코드를 컬럼으로 변환하려면  SUM(CASE WHEN  ...) 구문을 사용하여 변환할 수 있다.

## 11.4.9 ORDER BY 
Q. 쿼리 정렬시에 정렬데이터가 많아 Sort buffer 양을 초과했을때 디스크를 이용해 정렬을 수행하게 된다. 이 현상을 무엇이라고 부르는가?
> Filesort

## 11.4.10 서브쿼리 
Q. SELECT 절에 서브쿼리를 사용하면 항상 하나의 결과를반환한다 ?
> (O)

Q. FROM 절에 서브쿼리가 사용되면 항상 임시 테이블로 저장한다?
> (X) 5.7 이상버전부터 옵티마이저가 FROM절의 서브쿼리를 위부 쿼리로 병합하는 최적화 수행

Q. Where조건절에 사용되는 서브쿼리의 동작방식은 ?
> 5.5 이전버전에서 WHERE절에 사용되는 서브쿼리는 항상 메인쿼리 수행 후 서브쿼리를 수행하는 fillter방식으로 사용되었고, 5.5 이후버전에서는 정 반대로 실행될 수 있도록 개선되었음.

## 11.4.11 CTE(Common Table Expression)
- With절이랑 동일
- 비재귀적 CTE, 재귀적 CTE로 나뉨
- SQL문장이 종료되면 자동으로 삭제됨

## 11.4.12 윈도우 함수

Q. 윈도우 함수와 GROUP BY의 차이는?
> 윈도우 함수는 조회하는 현재 레코드를 기준으로 연관된 레코드의 집합연산 수행하고, GROUP BY는 주어진 그룹별로 하나의 레코드로 묶어서 출력함.

Q. DENSE_RANK(), RANK(), ROW_NUMBER() 의 차이는?
> DENSE_RANK() : 동점레코드가 두 건이상일때 동점인 레코드를 1건으로 가정하고 순위를 매김
> RANK() : 동점레코드가 두건 이상일 때 그다음 레코드를 동점인 레코드 수만큼 증가시킴
> ROW_NUMBER() :고유한 순번 반환

Q. 윈도우 함수는 성능이 좋아 OLTP성 환경에서 많은 레코드를 처리할 때 사용된다.
> X. 8.0 버전에 처음 도입되어 아직 인덱스를 이용한 최적화가 부족함

## 11.4.13 잠금을 사용하는 SELECT
Q. 레코드를 읽으면서 강제로 잠금을 걸어 둘 필요가 있을 때 사용하는 옵션은 ()절과 ()절이다.
> FOR SHARE, FOR UPDATE

Q. FOR SHARE와 FOR UPDATE의 차이는?
> FOR SHARE : SELECT 쿼리로 읽은 레코드에 대해서 읽기 잠금을 검
> FOR UPDATE : SELECT 쿼리로 읽은 레코드에 대해서 쓰기 잠금을 검

Q. 누군가가 레코드를 잠그고 있어 접근할 수 없을 때, 잠금 해제를 기다리지않고 에러 메시지를 출력시킬 수 있다. 이 옵션은 무엇인가?
> ex) FOR UPDATE NOWAIT

Q. SKIP LOCKED 옵션이란?
> SELECT 하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않고 잠금이 걸리지 않은 레코드만 가져오는 옵션

